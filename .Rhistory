head(bitcoin.df)
head(bitcoin.df)
dim(bitcoin.df)
summary(bitcoin.df)
library(forecast)
class(bitcoin.df$Date)
typeof(bitcoin.df$Date)
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7,1,11),
end = c(2018,1,1,0))
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7),
end = c(2018,1), frequency = 61320)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW")
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7),
end = c(2018,1), frequency = 4320)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW")
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW", ylim = 8.963e+10)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW", ylim = 89630000)
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7),
end = c(2018,1), frequency = 4320, ylim = 89630000)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW")
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7),
end = c(2018,1), frequency = 4320)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW",
ylim = c(0, 89630000))
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW",
ylim = c(0, 8.963e+10  ))
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW",
ylim = c(0, 4.963e+10  ))
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW",
ylim = c(0, 4e+10  ))
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW",
ylim = c(0, 5e+10  ))
bitcoin.lm <- lm(Volume.KRW ~ ., data = bitcoin.ts)
bitcoin.lm <- lm(Volume.KRW ~ ., data = bitcoin.df)
line(bitcoin.lm)
bitcoin.lm <- tslm(bitcoin.ts ~ Volume.KRW + I(Volume.KRW^2))
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2))
lines(bitcoin.lm$fitted.values, lwd = 2)
summary(bitcoin.lm)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^3), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^5), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^10), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, color = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, colour = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, colors = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^3), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "blue")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^5), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "green")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^10), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
lines(bitcoin.lm$fitted.values, lwd = 2, colors = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, colour = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, colours = "red")
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
lines(bitcoin.lm$fitted.values, lwd = 2, colours("red"))
lines(bitcoin.lm$fitted.values, lwd = 2, colour("red"))
source('~/RStudioProjects/TermProject/code.R', echo=TRUE)
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, color("red"))
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, color = "red")
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^3), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "blue")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^5), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "green")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^10), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
head(bitcoin.df)
View(bitcoin.df)
dim(bitcoin.df)
summary(bitcoin.df)
# Creating Time series model
library(forecast)
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7), end = c(2018,1), frequency = 4320)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW", ylim = c(0, 5e+10))
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^3), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "blue")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^5), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "green")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^10), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
summary(bitcoin.lm)
library(ggplot2)
library(tseries)
library(forecast)
count_ma = ts(bitcoin.df$Volume.KRW, start = c(2017,7), end = c(2018,1), frequency = 4320)
arima = auto.arima(count_ma)
arima <- forecast(arima, h=4320)
accuracy(arima)
arima <- forecast(arima, h=100)
accuracy(arima)
arima <- forecast(arima)
accuracy(arima)
plot(arima) + abline(h=20)
arima <- forecast(arima, h = 100)
accuracy(arima)
plot(arima) + abline(h=20)
plot(arima) + abline(h=20)
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-01-01");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
View(all_dates)
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = bitcoin.df[bitcoin.df$Date == filterdate,]
#now I want do do some processing on my_subset...
}
View(train.df)
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
startDate = as.POSIXct("2018-01-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
valid.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
View(valid.df)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
row_sub = apply(bitcoin.df, 1, function(row) all(row!=0))
bitcoin.df <- bitcoin.df[row_sub, ]
library(ggplot2)
library(tseries)
library(forecast)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
row_sub = apply(bitcoin.df, 1, function(row) all(row!=0))
bitcoin.df <- bitcoin.df[row_sub, ]
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
startDate = as.POSIXct("2018-01-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
valid.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
bitcoin.df <- bitcoin.df[!apply(bitcoin.df, 1, function(y) any(y==0)), ]
library(dplyr)
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
library(ggplot2)
library(tseries)
library(forecast)
library(dplyr)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2017-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
startDate = as.POSIXct("2018-01-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 86400); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
valid.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
head(bitcoin.df)
View(bitcoin.df)
dim(bitcoin.df)
summary(bitcoin.df)
View(valid.df)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24)
View(count_ma)
Dim(count_ma)
dim(count_ma)
dim(count_ma)
dim(count_ma)[1]
dim(count_ma)[0]
head(count_ma)
View(count_ma)
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24, start = c(2017,7))
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
library(ggplot2)
library(tseries)
library(forecast)
library(dplyr)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
library(ggplot2)
library(tseries)
library(forecast)
library(dplyr)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600); #86400 is num of seconds in a day
#the following code I'm trying to run inside a loop...
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
#now I want do do some processing on my_subset...
}
library(ggplot2)
library(tseries)
library(forecast)
library(dplyr)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
library(ggplot2)
library(tseries)
library(forecast)
library(dplyr)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
View(bitcoin.df)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
1");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDat
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-31");
all_dates = seq(startDate, endDate, 3600);
View(all_dates)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-12-30");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
View(train.df)
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-07-30");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
View(train.df)
# 2019년 데이터는 1월 데이터 일부가 누락되어 있기 때문에
# 2019년 2월 부터 시작한다.
startDate = as.POSIXct("2018-08-01");
endDate = as.POSIXct("2019-04-15");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
valid.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
# Creating Time series model
library(forecast)
bitcoin.ts <- ts(bitcoin.df$Volume.KRW, start = c(2017,7), end = c(2018,1), frequency = 4320)
plot(bitcoin.ts, xlab = "Hour", ylab = "bitcoin Volume.KRW", ylim = c(0, 5e+10))
# Create Linear model
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^2), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "red")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^3), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "blue")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^5), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2, col = "green")
bitcoin.lm <- tslm(bitcoin.ts ~ trend + I(trend^10), lambda = "auto")
lines(bitcoin.lm$fitted.values, lwd = 2)
summary(bitcoin.lm)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24, start = c(2017,7))
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24, start = c(2017,07))
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
pg(arima)
ggplot(train.df, aes(train.df$Date, train.df$Volume.KRW) + geom_point() + scale_x_date('hour'))
train.df$Volume.KRW <- log2(train.df$Volume.KRW)
source('~/RStudioProjects/TermProject/code.R', echo=TRUE)
ggplot(train.df, aes(train.df$Date, train.df$Volume.KRW) + geom_point() + scale_x_date('hour'))
ggplot(train.df, aes(train.df$Date, train.df$Volume.KRW)) + geom_point() + scale_x_date('hour')
ggplot(train.df, aes(train.df$Date, train.df$Volume.KRW)) + geom_point() + scale_x_date('month')
ggplot(train.df, aes(train.df, train.df$Volume.KRW)) + geom_point() + scale_x_date('month')
ggplot(train.df, aes(Date, Volume.KRW)) + geom_point() + scale_x_date('month')
train.df$Volume.KRW <- log2(train.df$Volume.KRW)
train.df$Volume.KRW <- log2(train.df$Volume.KRW)
# data preprocessing
bitcoin.df <- read.csv("Bitcoin_Hourly.csv")
bitcoin.df <- na.omit(bitcoin.df)
bitcoin.df <- bitcoin.df[,-2]
bitcoin.df$Date = as.POSIXct(bitcoin.df$Date, format = "%Y-%m-%d %I-%p")
bitcoin.df <- bitcoin.df[ order(bitcoin.df$Date, decreasing = FALSE), ]
bitcoin.df <- filter(bitcoin.df, bitcoin.df$Volume.KRW > 0)
# data partitioning
startDate = as.POSIXct("2017-07-01");
endDate = as.POSIXct("2018-07-30");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
train.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
# 2019년 데이터는 1월 데이터 일부가 누락되어 있기 때문에
# 2019년 2월 부터 시작한다.
startDate = as.POSIXct("2018-08-01");
endDate = as.POSIXct("2019-04-15");
all_dates = seq(startDate, endDate, 3600);
for (j in 1:length(all_dates)) {
filterdate = all_dates[j];
valid.df = subset(bitcoin.df, bitcoin.df$Date %in% all_dates)
}
# using ARIMA
train.df$Volume.KRW <- log2(train.df$Volume.KRW)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24, start = c(2017,07))
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
count_ma = ts(train.df$Volume.KRW, frequency = 365*24, start = c(2017,07), end = c(2018,07))
arima = auto.arima(count_ma)
arima <- forecast(arima, h = 365*24)
accuracy(arima)
plot(arima) + abline(h=20)
install.packages('forecast', dependencies = TRUE)
install.packages("forecast", dependencies = TRUE)
install.packages("forecast", dependencies = TRUE)
detach(forecast)
detach("forecast")
detach("package:forecast", unload = TRUE)
detach_package("forecast", TRUE)
install.packages('forecast', dependencies = TRUE)
install.packages("forecast", dependencies = TRUE)
install.packages("forecast")
install.packages("forecast")
library(ggplot2)
library(tseries)
library(forecast)
library(forecast)
